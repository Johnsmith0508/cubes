<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"client.js.html":{"id":"client.js.html","title":"Source: client.js","body":" GUI.js Namespaces GUI Classes GUI.guiSceneGUI.guiScene#InventoryItemItemStack Tutorials GUI.guiScene#InventoryGUI.guiSceneItem Global animateChatinitkeyuser Source: client.js /*global $ THREE force initThree updatePhysics world CapsuleColider*/ if(typeof Promise === &quot;undefined&quot; || Promise.toString().indexOf(&quot;[native code]&quot;) === -1){throw new TypeError(&quot;Browser does not support promises&quot;);} var test, debugModel, cubeItem, effect, enableVr = false; var usedConsoleLogs = /^((?!\\/\\/).)*console\\.log*/gi; var scene, guiScene, camera, renderer, objMtlLoader, JsonLoader, gui, chatHideDelay, userName = &quot;&quot;, debugItem, inventory, hotbar, isShifted, blendMesh, testsprite, cannonDebugRenderer, cubeGeometry, cubeMaterial, clientCubeMaterial, carGeometry, carMaterial, controls, floorMaterial, wallsMaterial, light, ambientLight; var color; //create socket.io connection to server var socket = new io('//dynalogic.org', { path: '/node/socket.io' }); //initiate stats.js var stats = new Stats(); /** object that tracks the keys pressed */ var key = { forward: false, left: false, back: false, right: false, q: false, e: false, chat: false, up: false, down: false, keyPressed: 0, angle: 0 }; var keycode = { forward: 87, back: 83, left: 65, right: 68, up: 32, down: 16, reset: 82, chat: 84, inventory: 73, close: 27 } /** Object of all users @private */ var user = {}; var groundItems = []; //so the server is only told about no keys being pressed once var sendUpdateNoKey = true; var directonalForce = new CANNON.Vec3(0, 0, 0); var jumpForce = new CANNON.Vec3(0, 10, 0); var canJump = true; var config = loadJson('./config.json'); var itemInfo = loadJson('./items.json'); loadJavascript(&quot;./items.js&quot;); var items = []; //handles the sending of keys to the server var buttonHandler = function(keyPressed, status) { if (keyPressed.target === $(&quot;.chat&quot;)) return; switch (keyPressed.which) { case keycode.forward: key.forward = status; break; case keycode.back: key.back = status; break; case keycode.left: key.left = status; break; case keycode.right: key.right = status; break; case keycode.up: key.up = status; break; case keycode.chat: key.chat = status; break; case keycode.reset: controls.reset(); break; case keycode.inventory: if (status) inventory.toggle(); break; case keycode.close: inventory.hide(); } if (keyPressed.shiftKey) { key.down = true; } else { key.down = false; } } var registerEvents = function() { //called when a user joins the server socket.on('user joined', function(data) { if (typeof user[data.name] == &quot;undefined&quot; &amp;&amp; typeof userName != &quot;undefined&quot;) { user[data.name] = new CapsuleColider(1, 4, data.name); user[data.name].position.fromArray(data.position); user[data.name].rotation.fromArray(data.rotation); user[data.name].items = {}; world.addBody(user[data.name].phisObj); scene.add(user[data.name].phisMesh); scene.add(user[data.name]); } }); //sent when a user leaves socket.on('user left', function(name) { scene.remove(user[name]); scene.remove(user[name].phisMesh); world.removeBody(user[name].phisObj); delete user[name]; }); //meh socket.on('physics change', function(data) { if (typeof user[userName] !== &quot;undefined&quot;) { user[data.name].realPosition.set(data.position.x, data.position.y, data.position.z); user[data.name].phisObj.velocity.set(data.velocity.x, data.velocity.y, data.velocity.z); user[data.name].phisObj.quaternion.set(data.quaternion.x, data.quaternion.y, data.quaternion.z, data.quaternion.w); } }); socket.on('error', function(error) { if (error == &quot;user exists&quot;) { $(&quot;#ErrorMsg&quot;).val(&quot;Username is in use, Try annother&quot;); $(&quot;#ErrorMsg&quot;).show(); registerSubmitButton(); } }); socket.on('user created', function() { preInit(); }); socket.on('item', function(data) { var itemPosition = -1; for (var i = 0; i &lt; groundItems.length; i++) { if (groundItems[i].id == data.id) { itemPosition = i; } } if (itemPosition == -1) { switch (data.name) { case &quot;debugItem&quot;: groundItems.push(new ItemStack(debugItem, data.id, data.ammount)); groundItems[groundItems.length - 1].model.material.materials[0].color.setHex('0x' + randomColor().substring(1, 7)) break; case &quot;cubeItem&quot;: groundItems.push(new ItemStack(cubeItem, data.id, data.ammount)); groundItems[groundItems.length - 1].model.material.color.setHex('0x' + randomColor().substring(1, 7)); break; } itemPosition = groundItems.length - 1; scene.add(groundItems[itemPosition].model); } groundItems[itemPosition].model.position.copy(data.position); }); socket.on('itemRemove', function(data) { for (var i = 0; i &lt; groundItems.length; i++) { if (groundItems[i].id == data.id) { scene.remove(groundItems[i].model); if (data.user === userName) { if (typeof inventory.locateItem(data.itemName) !== &quot;undefined&quot;) { var itemLocation = inventory.locateItem(data.itemName); inventory.items[itemLocation[0]][itemLocation[1]].ammount++; } else { inventory.addItemToEmptySlot(groundItems[i]); } } groundItems.splice(i, 1); } } }); socket.on('itemHeld', function(data) { if (typeof user[data.name] !== &quot;undefined&quot;) { user[data.name].items = data.items; } }); socket.on('latencyCheck', function(oldTime) { var time = new Date().getTime(); $(&quot;#pingDisplay&quot;).text(Math.floor((time - oldTime) / 2) + &quot;ms&quot;); }); } //handles the logic behind the submit button on the login screen var submitHandler = function() { $('#name').off('keyup'); registerEvents(); if ($(&quot;#name&quot;).val().length &gt; 0) { modelType = $(&quot;.model:checked&quot;).val(); socket.emit('create user', { name: $(&quot;#name&quot;).val(), model: modelType, cookie: getCookie('login'), hashedPassword: getCookie('hashpass'), keyConfig: JSON.stringify(keycode) }); } } //call to enable the submit button on the main page var registerSubmitButton = function() { $(&quot;#sendName&quot;).one('click', submitHandler); $('#name').on('keyup', function(e) { if (e.keyCode === 13) { $('#sendName').trigger('click'); } }); } //function that contains all logic for various things var mainLoop = function() { if (typeof user[userName] === &quot;undefined&quot;) return; key.angle = controls.getAzimuthalAngle(); inventory.update(); directonalForce.setZero(); if (key.forward) { directonalForce.add(-Math.sin(key.angle), 0, -Math.cos(key.angle)); } else { directonalForce.add(Math.sin(key.angle), 0, Math.cos(key.angle)); } if (key.back) { directonalForce.add(Math.sin(key.angle), 0, Math.cos(key.angle)); } else { directonalForce.add(-Math.sin(key.angle), 0, -Math.cos(key.angle)); } if (key.left) { directonalForce.add(-Math.sin(key.angle + Math.PI / 2), 0, -Math.cos(key.angle + Math.PI / 2)); } else { directonalForce.add(Math.sin(key.angle + Math.PI / 2), 0, Math.cos(key.angle + Math.PI / 2)); } if (key.right) { directonalForce.add(Math.sin(key.angle + Math.PI / 2), 0, Math.cos(key.angle + Math.P / 2)); } else { directonalForce.add(-Math.sin(key.angle + Math.PI / 2), 0, -Math.cos(key.angle + Math.P / 2)); } if (key.up &amp;&amp; canJump) { user[userName].phisObj.applyImpulse(jumpForce, user[userName].phisObj.position); canJump = false; } if (key.down) directonalForce.add(0, -0.25, 0); directonalForce.normalize(); if (key.forward || key.back || key.left || key.right || key.q || key.e || key.up || key.down) { user[userName].phisObj.applyImpulse(directonalForce, user[userName].phisObj.position); sendUpdateNoKey = true; socket.emit('keys pressed', key); } else if (userName.length &gt; 0) { user[userName].phisObj.velocity.x *= 0.75; user[userName].phisObj.velocity.z *= 0.75; if (sendUpdateNoKey) { sendUpdateNoKey = false; socket.emit('keys pressed', key); } } for (var i in user) { if (user[i].phisObj.position.distanceTo(user[i].realPosition) &lt; 4 || i === userName) { user[i].phisObj.position.lerp2(user[i].realPosition, 0.1); } else { user[i].phisObj.position.copy(user[i].realPosition); } } } var preInit = function() { userName = $(&quot;#name&quot;).val(); $('#login').hide(); $(&quot;#threeJsRenderWindow&quot;).append(renderer.domElement); $('#main_window').show(); chatHideDelay = $(&quot;#chatDelay&quot;).val(); //addText(&quot;test&quot;,camera); $(document).on('keydown', function(e) { if (e.target.id != &quot;msgIn&quot;) buttonHandler(e, true); }); $(document).on('keyup', function(e) { if (e.target.id != &quot;msgIn&quot;) buttonHandler(e, false); }); user[userName] = new CapsuleColider(1, 4, userName); switch (modelType) { case &quot;car&quot;: scene.add(camera); user[userName].model = new THREE.Mesh(carGeometry, carMaterial); user[userName].model.scale.set(0.6, 0.6, 0.6); user[userName].model.rotateX(-Math.PI / 2); user[userName].model.rotateZ(Math.PI); user[userName].updateMatrixWorld(); user[userName].add(user[userName].model); THREE.SceneUtils.attach(camera, scene, user[userName]); break; case &quot;person&quot;: user[userName] = new THREE.Mesh(blendMesh.geometry, blendMesh.material); user[userName].scale.set(0.01, 0.01, 0.01); scene.add(user[userName]); user[userName].add(camera); break; default: user[userName].add(camera); user[userName].items = {}; } scene.add(user[userName]); world.addBody(user[userName].phisObj); //scene.add(user[userName].phisMesh); var nameGuiElement = gui.addTextElement(userName, window.innerWidth / -2, window.innerHeight / 2 - 20, { textColor: &quot;#262626&quot; }); nameGuiElement.position.x += nameGuiElement.scale.x / 2; if ($(&quot;#vrEnable&quot;).is(&quot;:checked&quot;)) { enableVr = true; } if ($(&quot;#fpsShow&quot;).is(&quot;:checked&quot;)) { document.body.appendChild(stats.domElement); } else { registerSubmitButton(); } var chat = new Chat(socket, keycode.chat, { closeKey: keycode.close, hideDelay: $(&quot;#chatDelay&quot;).val() }); //document.getElementById(&quot;main_window&quot;).appendChild(chat); } var addGroundItem = function(name, location, model, index) { var index1 = index || groundItems.length; model = model.clone(); groundItems.splice(index1, 0, { name: name, position: location, model: model, update: function() { this.model.position.copy(this.position); } }); scene.add(model); return groundItems.length - 1; } //initilise all required variables /** * Init function * @function */ function init() { //create three.js scene / init loaders scene = new THREE.Scene(); JsonLoader = new THREE.JSONLoader(); blendMesh = new THREE.BlendCharacter(); gui = new GUI.guiScene(); inventory = new gui.Inventory(5, 9); hotbar = new gui.Inventory(1, 10); hotbar.containerObject.position.y = window.innerHeight / -2 + 100; hotbar.toggle(); hotbar.mouseItem = inventory.mouseItem; //configure stats stats.setMode(0); stats.domElement.style.position = &quot;absolute&quot;; stats.domElement.style.left = '0px'; stats.domElement.style.top = '0px'; //init camera camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 10000); scene.add(camera); camera.position.x = -7; camera.position.y = 5; camera.lookAt(force.zero); //init geometries planeGeom = new THREE.PlaneGeometry(30, 30); cubeGeometry = new THREE.BoxGeometry(1, 1, 1); //lights light = new THREE.PointLight(0xffffff, 1, 100); light.position.y = 15; light.position.z = 5; light.position.x = -7; scene.add(light); ambientLight = new THREE.AmbientLight(0x404040); // soft white light scene.add(ambientLight); //scene.add(new THREE.AmbientLight( 0xaaaaaa )); //init materials carMaterial = new THREE.MeshPhongMaterial(); carMaterial.shading = THREE.FlatShading; planeMaterial = new THREE.MeshBasicMaterial({ color: 0x9966ff, side: THREE.DoubleSide }); cubeMaterial = new THREE.MeshBasicMaterial({ color: 0xffa000, wireframe: false }); clientMaterial = new THREE.MeshBasicMaterial({ color: 0x003366, wireframe: false }); //add static scene objects plane = new THREE.Mesh(planeGeom, planeMaterial); plane.rotation.x = Math.PI / 2; plane.reciveShadow = true; //scene.add(plane); $.getScript('./items.js', function(data, textStatus, jqxhr) { var j = 0; for (var i in itemInfo) { var id = itemInfo[i].id; items[id] = itemScripts[itemInfo[i].name] || {}; itemInfo[i].modelLoader = itemInfo[i].modelLoader || &quot;&quot;; switch (itemInfo[i].modelLoader.toLowerCase()) { case &quot;objmtl&quot;: items[id].promisedModel = new Promise(function(resolve, reject) { objMtlLoader.load(itemInfo[i].model, itemInfo[i].mtl, function(object) { items[id].model = object; resolve(object); }); }); break; case &quot;json&quot;: items[id].promisedModel = new Promise(function(resolve, reject) { JsonLoader.load(itemInfo[i].model, function(geom, materials) { var material = new THREE.MultiMaterial(materials); items[id].model = new THREE.Mesh(geom, material); resolve(items[id].model); }); }); break; default: items[id].promisedModel = new Promise(function(resolve, reject) { items[id].model = new THREE.Mesh(cubeGeometry, cubeMaterial); resolve(items[id].model); }); } items[id].promisedModel.then(function(model) { items[id].item = new Item(itemInfo[i].name, model, id, items[id].leftClick, items[id].rightClick); }); j++; } }); test = new THREE.Mesh(cubeGeometry, cubeMaterial); //load externals JsonLoader.load('/node/model/testObject.js', function(geometry, materials) { var material = new THREE.MultiMaterial(materials); debugModel = new THREE.Mesh(geometry, material); debugModel.scale.set(0.1, 0.1, 0.1); debugItem = new Item(&quot;debugItem&quot;, debugModel, 7, {}, [&quot;hello&quot;, &quot;test&quot;, &quot;This is some default flavor text to be displayed&quot;, &quot;bleow the item&quot;, &quot;(I hate this project)&quot;]); //scene.add( object ); }); blendMesh.load('model/marine_anims.js', function() { blendMesh.scale.set(0.01, 0.01, 0.01); //guiScene.add(blendMesh); }); initThree(scene); initCannon(); cubeItem = new Item(&quot;cubeItem&quot;, test); cannonDebugRenderer = new THREE.CannonDebugRenderer(scene, world); //init renderer renderer = new THREE.WebGLRenderer({ alpha: true }); renderer.setSize(window.innerWidth, window.innerHeight); renderer.autoClear = false; effect = new THREE.StereoEffect(renderer /* , { worldScale: 1} */ ); effect.setSize(window.innerWidth, window.innerHeight); controls = new THREE.OrbitControls(camera, renderer.domElement); controls.enableDamping = true; controls.dampingFactor = 0.25; controls.enablePan = false; registerSubmitButton(); } /** * Function to render the scene(s) */ function animate() { stats.begin(); mainLoop(); upadtePhysics(); controls.update(); cannonDebugRenderer.update(); stats.end(); requestAnimationFrame(animate); renderer.render(scene, camera); if (enableVr) { effect.render(scene, camera); //effect.render(gui.scene, gui.camera); } gui.render(renderer); } //does the 'players online' bit socket.on('user count', function(users) { $(&quot;#usersOnline&quot;).text(users + &quot; online currently&quot;); }); //socket.on(*), part of a failed project //run init init(); //begin rendering animate(); //toggles hiding/showing options pannel $(function() { socket.on('keyConfig', function(data) { if (data.name === getCookie('login')) { try { var parsedConfig = JSON.parse(data.config); keycode = parsedConfig; for (var i in keycode) { switch (keycode[i]) { case 37: $(&quot;#&quot; + i).html(&quot;&amp;larr;&quot;); break; case 38: $(&quot;#&quot; + i).html(&quot;&amp;uarr;&quot;); break; case 39: $(&quot;#&quot; + i).html(&quot;&amp;rarr;&quot;); break; case 40: $(&quot;#&quot; + i).html(&quot;&amp;darr;&quot;); break; case 17: $(&quot;#&quot; + i).text(&quot;ctrl&quot;); break; case 16: $(&quot;#&quot; + i).text(&quot;shift&quot;); break; case 32: $(&quot;#&quot; + i).text(&quot;space&quot;); break; case 20: $(&quot;#&quot; + i).text(&quot;caps&quot;); break; case 9: $(&quot;#&quot; + i).text(&quot;tab&quot;); break; case 13: $(&quot;#&quot; + i).text(&quot;enter&quot;); break; case 18: $(&quot;#&quot; + i).text(&quot;alt&quot;); break; case 93: $(&quot;#&quot; + i).text(&quot;menu&quot;); break; case 91: $(&quot;#&quot; + i).text(&quot;win key&quot;); break; default: $(&quot;#&quot; + i).text(String.fromCharCode(keycode[i]).toLowerCase()); } } } catch (e) { console.log(e); } } }); config.then(function(data){$(&quot;#server&quot;).val(data.defaultServer);}); if (getCookie('login')) { $(&quot;#name&quot;).hide().val(getCookie('login')); $(&quot;#loginTypes&quot;).hide(); $(&quot;#logoutButton&quot;).show(); socket.emit('getKeyConfig', getCookie('login')); } $(&quot;#opts&quot;).on('click', function() { $(&quot;#options&quot;).toggle(); }); }); setInterval(function() { socket.emit('latencyCheck', new Date().getTime()); }, 1000); //handle window changing size function onWindowResize() { windowHalfX = window.innerWidth / 2; windowHalfY = window.innerHeight / 2; camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); //GUI.camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); } //register previous function window.addEventListener('resize', onWindowResize, false); CANNON.Vec3.prototype.lerp2 = function(v, t) { this.x = this.x + (v.x - this.x) * t; this.y = this.y + (v.y - this.y) * t; this.z = this.z + (v.z - this.z) * t; return this; } CANNON.Vec3.prototype.lerp3 = function(x, y, z, t) { this.x = this.x + (x - this.x) * t; this.y = this.y + (y - this.y) * t; this.z = this.z + (z - this.z) * t; return this; } × Search results Close Documentation generated by JSDoc 3.4.0 on 2016-05-31T11:24:01+00:00 using the DocStrap template. "},"chat.js.html":{"id":"chat.js.html","title":"Source: chat.js","body":" GUI.js Namespaces GUI Classes GUI.guiSceneGUI.guiScene#InventoryItemItemStack Tutorials GUI.guiScene#InventoryGUI.guiSceneItem Global animateChatinitkeyuser Source: chat.js /** @construtor @param {socket.io} socket - socket.io connection to use */ var Chat = function(socket, keyCode, opts) { opts = opts || {}; opts.hideDelay = opts.hideDelay || 5; opts.closeKey = opts.closeKey || 27; var timeout; this.element = createElement(&quot;div&quot;).setClass(&quot;chat&quot;).createElement(&quot;ul&quot;, { id: &quot;messages&quot; }).createElement(&quot;input&quot;, { id: &quot;msgIn&quot; }).createElement(&quot;button&quot;, { id: &quot;send&quot; }); this.chatOpen = false; var atBottom = true; $(&quot;#send&quot;).on('click', function() { this.chatOpen = false; if ($(&quot;#msgIn&quot;).val().length &gt; 0) { socket.emit('chat message', $(&quot;#msgIn&quot;).val()); $(&quot;#msgIn&quot;).val(''); $(&quot;.chat&quot;).hide(); } }); socket.on('chat message', function(payload) { $(&quot;.chat&quot;).show(); if (atBottom) { $('#messages').append($('&lt;li&gt;').text(payload)); $(&quot;#messages&quot;).scrollTop($(&quot;#messages&quot;)[0].scrollHeight + 28); } else { $('#messages').append($('&lt;li&gt;').text(payload)); } if (!this.chatOpen) { clearTimeout(timeout); timeout = setTimeout(function() { $(&quot;.chat&quot;).hide(); }, opts.hideDelay * 1000); } }); $(&quot;#messages&quot;).scroll(function() { if ($(&quot;#messages&quot;).scrollTop() + $(&quot;#messages&quot;).innerHeight() == document.getElementById(&quot;messages&quot;).scrollHeight) { atBottom = true; } else { atBottom = false; } }); $(document).on('keyup', function(e) { if (e.which === keyCode) { $(&quot;.chat&quot;).show(); $(&quot;#msgIn&quot;).focus(); clearTimeout(timeout); hasChatOpen = true; } if (e.which === 13) { $(&quot;#send&quot;).trigger('click'); } if (typeof opts.closeKey !== &quot;undefined&quot;) { if (e.which === opts.closeKey) { $(&quot;.chat&quot;).hide(); } } }); return this.element; } × Search results Close Documentation generated by JSDoc 3.4.0 on 2016-05-31T11:24:02+00:00 using the DocStrap template. "},"GUI.js.html":{"id":"GUI.js.html","title":"Source: GUI.js","body":" GUI.js Namespaces GUI Classes GUI.guiSceneGUI.guiScene#InventoryItemItemStack Tutorials GUI.guiScene#InventoryGUI.guiSceneItem Global animateChatinitkeyuser Source: GUI.js /*global THREE */ if (typeof THREE === &quot;undefined&quot;) throw &quot;THREE.JS not found&quot;; /** @namespace */ var GUI = { version: '1.2.7' }; /** center of the scene */ GUI.origin = new THREE.Vector3(0, 0, 0); /** default control scheme */ GUI.CONTROL_SCHEME_DEFAULT = { /* intended behavior: if user has item on mouse and none in the selected slot, place item in slot if user has no item on mouse and one in selected slot, pick up item if user has item on mouse and in selected slot, switch items. unless they are the same item, then combine */ leftClick: function(inventory, x, y) { var itemInSlot = typeof inventory.items[x][y] !== &quot;undefined&quot;; var itemOnMouse = typeof inventory.mouseItem !== &quot;undefined&quot;; if (itemOnMouse &amp;&amp; !itemInSlot) { inventory.addItemToSlot(inventory.mouseItem, x, y); inventory.items[x][y].oldAmt = 0; delete inventory.mouseItem; } if (itemInSlot &amp;&amp; !itemOnMouse) { inventory.mouseItem = inventory.removeItem(x, y); delete inventory.items[x][y]; } if (itemInSlot &amp;&amp; itemOnMouse) { if (inventory.items[x][y].itemName == inventory.mouseItem.name) { inventory.items[x][y].ammount += inventory.mouseItem.ammount; delete inventory.mouseItem; return; } var standby = inventory.removeItem(x, y); inventory.addItemToSlot(inventory.mouseItem, x, y); inventory.mouseItem = standby; } }, /* intended behavior: if user has item on mouse and none in slot, add one to slot; remove one from mouse if user has item no item on mouse and one in slot, remove half from the slot (floor num in slot, celing num on mouse) if user has item on mouse and item in hand, switch them. unless they are the same, then add one to slot &amp; remove one from mouse */ rightClick: function(inventory, x, y) { var itemInSlot = typeof inventory.items[x][y] !== &quot;undefined&quot;; var itemOnMouse = typeof inventory.mouseItem !== &quot;undefined&quot;; if (itemOnMouse &amp;&amp; !itemInSlot) { inventory.mouseItem.ammount--; var addedItem = inventory.mouseItem.clone(); addedItem.ammount = 1; inventory.addItemToSlot(addedItem, x, y); inventory.items[x][y].oldAmt = 0; } if (!itemOnMouse &amp;&amp; itemInSlot) { var stackAmnt = inventory.items[x][y].ammount / 2; inventory.items[x][y].ammount = Math.floor(stackAmnt); if(inventory.items[x][y].ammount &lt;= 0) { inventory.mouseItem = inventory.removeItem(x,y); } else { inventory.mouseItem = inventory.items[x][y].itemStack.clone(); // inventory.mouseItem.ammount = inventory.items[x][y].ammount; } inventory.mouseItem.ammount = Math.ceil(stackAmnt); } if (itemInSlot &amp;&amp; itemOnMouse) { if (inventory.items[x][y].itemName == inventory.mouseItem.name) { inventory.items[x][y].ammount++; inventory.mouseItem.ammount--; return; } var standby = inventory.removeItem(x, y); inventory.addItemToSlot(inventory.mouseItem, x, y); inventory.mouseItem = standby; } } }; /** @constructor */ GUI.guiScene = function() { var self = this; /** the camera that is used @private */ self.camera = new THREE.OrthographicCamera(window.innerWidth / -2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / -2, -500, 1000); self.light = new THREE.AmbientLight(0xffffff); /** the actual scene that is rendered @deprecated use {@link GUI.guiScene.addElement} instead */ self.scene = new THREE.Scene(); self.scene.add(self.camera); self.scene.add(self.light); self.camera.position.z = 50; self.camera.lookAt(GUI.origin); /** add an element to the gui @function @param {Object3D} object - object to add to the scene @returns {Object3D} the passed object */ self.addElement = function(object) { self.scene.add(object); return object; } /** render the scene @function @param {THREE.renderer} renderer - the THREE.js renderer that is used to render this */ self.render = function(renderer) { renderer.render(self.scene, self.camera); } /** add text to the gui @param {String} text - the text to be added @param {Int} x - x position (0,0 is center of screen) @param {Int} y - y position (0,0 is center of screen) @param {Object} [opts] - extra options to be passed @param {Int} [opts.z] - z-index of the object @returns {Object3D} the object that contains the text */ self.addTextElement = function(text, x, y, opts) { if (typeof opts === &quot;undefined&quot;) opts = {}; if (typeof opts.z === &quot;undefined&quot;) opts.z = 0; if (typeof opts.textColor === &quot;undefined&quot;) opts.textColor = &quot;#000&quot;; var canvas = document.createElement('canvas'), canvasContext = canvas.getContext('2d'); canvas.style.border = '3px solid #000'; canvas.style.borderRadius = '15px'; canvas.height = 105; canvasContext.font = &quot;100px Arial&quot;; var textWidth = canvasContext.measureText(text).width; canvas.width = textWidth; canvasContext.font = &quot;normal 100px Arial&quot;; //canvasContext.fillStyle = &quot;#f06&quot;; //roundRect(canvasContext, 1, 1, (textWidth - 2), 100, 8); canvasContext.fillStyle = opts.textColor; canvasContext.fillText(text, 0, 85); var texture = new THREE.Texture(canvas); texture.needsUpdate = true; var material = new THREE.SpriteMaterial({ map: texture }); var sprite = new THREE.Sprite(material); sprite.scale.set(textWidth / 4, 25, 25); sprite.position.set(x, y, opts.z); self.scene.add(sprite); //scene.add(sprite); sprite.position.y += 1.5; sprite.textWidth = textWidth; return sprite; } /** @constructor @param {int} rows - number of rows in the gui @param {int} columns - number of columns in gui @param {object} [opts] - options @param {color} [opts.backgroundColor] - background UI color @param {color} [opts.lineColor] - color of lines in UI @param {object} [opts.ctrlScheme] - functions to be called when various buttons are clicked @memberof GUI @alias guiScene#Inventory */ self.Inventory = function(rows, columns, opts) { var invSelf = this; opts = opts || {}; opts.backgroundColor = opts.backgroundColor || &quot;#fff&quot;; opts.lineColor = opts.lineColor || &quot;#000&quot;; this.ctrlScheme = opts.ctrlScheme || GUI.CONTROL_SCHEME_DEFAULT; this.height = rows * 100 + 1; this.width = columns * 100 + 1; this.rows = rows; this.columns = columns; this.items = new Array(columns); for (var i = 0; i &lt; this.items.length; i++) { this.items[i] = new Array(rows); } this.canvas = document.createElement(&quot;canvas&quot;); this.canvas.height = this.height; this.canvas.width = this.width; this.grid = this.canvas.getContext(&quot;2d&quot;); this.grid.beginPath(); this.grid.rect(0, 0, this.width, this.height); this.grid.fillStyle = opts.backgroundColor; this.grid.font = &quot;30px Arial&quot;; this.grid.fill(); this.grid.lineWidth = 5; this.grid.strokeStyle = opts.lineColor; this.grid.moveTo(0, 0); this.grid.lineTo(0, this.height); this.grid.lineTo(this.width, this.height); this.grid.lineTo(this.width, 0); this.grid.lineTo(0, 0); this.grid.stroke(); this.grid.lineWidth = 2; for (var i = 0; i &lt;= this.width; i += 100) { this.grid.moveTo(i, 0); this.grid.lineTo(i, this.height); } for (var i = 0; i &lt;= this.height; i += 100) { this.grid.moveTo(0, i); this.grid.lineTo(this.width, i); } this.grid.stroke(); self.mouseItem = {}; this.grid.fillStyle = opts.lineColor; //document.body.appendChild(this.canvas); this.texture = new THREE.Texture(this.canvas); this.texture.minFilter = THREE.LinearFilter; this.texture.needsUpdate = true; this.material = new THREE.SpriteMaterial({ map: this.texture }); this.sprite = new THREE.Sprite(this.material); this.sprite.scale.set(this.width, this.height, 1); this.hidden = true; this.containerObject = new THREE.Object3D(); this.containerObject.add(this.sprite); /** adds an item to the selected Slot @param {ItemStack} itemStack - Itemstack to add to the inv @param {int} x - column to place item in (0 is far left) @param {int} y - row to place item in (0 is top) @return {Array} coordinates that the item were added to */ this.addItemToSlot = function(itemStack, x, y) { this.items[x][y] = itemStack.model.clone(); this.items[x][y].ammount = itemStack.ammount; this.items[x][y].oldAmt = itemStack.ammount; this.items[x][y].itemName = itemStack.name; this.items[x][y].itemStack = itemStack; this.items[x][y].lore = itemStack.lore; var xPos = ((this.width / -2) + (x * 100) + 50); var yPos = ((this.height / 2) - (y * 100) - 50); this.items[x][y].position.set(xPos, yPos, 0); this.items[x][y].scale.multiplyScalar(50); this.containerObject.add(this.items[x][y]); return [x, y]; } /** find the next empty slot in the inventory @return {Array} next empty slot */ this.getEmptySlot = function() { for (var j = 0; j &lt; this.rows; j++) { for (var i = 0; i &lt; this.columns; i++) { if (typeof this.items[i][j] === &quot;undefined&quot;) { return [i, j]; } } } } /** add item to the next slot @param {ItemStack} itemStack - the ItemStack to be added */ this.addItemToEmptySlot = function(itemStack) { var pos = this.getEmptySlot(); this.addItemToSlot(itemStack, pos[0], pos[1]); } /** removes item from slot @param {int} x - x-coord of slot to be removed from @param {int} y - y-coord of slot to be removed from @return {ItemStack} removed ItemStack */ this.removeItem = function(x, y) { if (typeof this.items[x][y] === &quot;undefined&quot;) return false; this.containerObject.remove(this.items[x][y]); var ret = this.items[x][y].itemStack.clone(); ret.ammount = this.items[x][y].ammount; this.grid.fillStyle = opts.backgroundColor; this.grid.fillText(this.items[x][y].oldAmt, x * 100 + 5, y * 100 + 30); delete this.items[x][y].ammount; delete this.items[x][y]; return ret; } /** shows the Inventory */ this.show = function() { self.scene.add(this.containerObject); this.hidden = false; } /** hides the inventory */ this.hide = function() { self.scene.remove(this.containerObject); this.hidden = true; } /** toggles the inventory visiblity @return this */ this.toggle = function() { if (this.hidden) { this.show(); } else { this.hide(); } return this; } /** update function to be called every frame */ this.update = function() { for (var i = 0; i &lt; this.items.length; i++) { for (var j = 0; j &lt; this.items[i].length; j++) { if (typeof this.items[i][j] !== &quot;undefined&quot;) { this.items[i][j].rotation.y += 0.05; if (this.items[i][j].oldAmt != this.items[i][j].ammount) { this.grid.fillStyle = opts.backgroundColor; this.grid.fillText(this.items[i][j].oldAmt, i * 100 + 5, j * 100 + 30); this.grid.fillStyle = opts.lineColor; this.grid.fillText(this.items[i][j].ammount, i * 100 + 5, j * 100 + 30); this.items[i][j].oldAmt = this.items[i][j].ammount; this.texture.needsUpdate = true; } } } } } /** find first occurence of item in inventory @param {string} itemName - name of item to find @return {Array} coordinates of first occurance of the item */ this.locateItem = function(itemName) { var ret = []; for (var i = 0; i &lt; this.items.length; i++) { for (var j = 0; j &lt; this.items[i].length; j++) { if (typeof this.items[i][j] !== &quot;undefined&quot; &amp;&amp; this.items[i][j].itemName == itemName) { return [i, j]; } } } return ret.length &gt; 1 ? ret : ret[0]; } window.addEventListener('mousedown', function(e) { var row = Math.floor((window.innerHeight / -2 + invSelf.height / 2 + e.clientY) / 100); var col = Math.floor((window.innerWidth / -2 + invSelf.width / 2 + e.clientX) / 100); if (!invSelf.hidden &amp;&amp; col &lt;= invSelf.columns - 1 &amp;&amp; row &lt;= invSelf.rows - 1 &amp;&amp; row &gt;= 0 &amp;&amp; col &gt;= 0) { if(typeof invSelf.items[col][row] !== &quot;undefined&quot; &amp;&amp; typeof invSelf.items[col][row].lore !== &quot;undefined&quot;) { self.scene.remove(invSelf.items[col][row].lore); } switch (e.button) { case 0: invSelf.ctrlScheme.leftClick(invSelf, col, row); break; case 2: invSelf.ctrlScheme.rightClick(invSelf, col, row); break; } } }, false); var loreOpen = [-1,-1]; $('body').on('mousemove', function(e) { if (/*!invSelf.hidden*/ true) { var row = Math.floor((window.innerHeight / -2 + invSelf.height / 2 + e.clientY) / 100); var col = Math.floor((window.innerWidth / -2 + invSelf.width / 2 + e.clientX) / 100); var xPos = window.innerWidth / -2 + e.clientX; var yPos = window.innerHeight / 2 - e.clientY; if (loreOpen[0] &gt;= 0 &amp;&amp; loreOpen[1] &gt;= 0 &amp;&amp; (loreOpen[0] != col || loreOpen[1] != row) &amp;&amp; typeof invSelf.items[loreOpen[0]][loreOpen[1]] !== &quot;undefined&quot;) { self.scene.remove(invSelf.items[loreOpen[0]][loreOpen[1]].lore); loreOpen = [col,row]; } if (col &lt;= invSelf.columns - 1 &amp;&amp; row &lt;= invSelf.rows - 1 &amp;&amp; row &gt;= 0 &amp;&amp; col &gt;= 0 &amp;&amp; !invSelf.hidden) { if (typeof invSelf.items[col][row] !== &quot;undefined&quot; &amp;&amp; typeof invSelf.items[col][row].lore !== &quot;undefined&quot;) { self.scene.add(invSelf.items[col][row].lore); invSelf.items[col][row].lore.position.set(xPos + invSelf.items[col][row].lore.scale.x / 2, yPos - invSelf.items[col][row].lore.scale.y / 2, 150); loreOpen = [col,row]; } } } }); //iwindow.addEventListener('resize', function() { //invSelf.containerObject.scale.set(3 * window.innerHeight / window.innerWidth, 3 * window.innerHeight / window.innerWidth, 1); //invSelf.sprite.scale.set(invSelf.width * (window.innerHeight / window.innerWidth), invSelf.height * (window.innerHeight / window.innerWidth), invSelf.height); //console.info(invSelf.containerObject.scale); //}, false); return this; } window.addEventListener('resize', function() { self.camera.left = window.innerWidth / -2; self.camera.right = window.innerWidth / 2; self.camera.top = window.innerHeight / 2; self.camera.bottom = window.innerHeight / -2; self.camera.updateProjectionMatrix(); }, false); } /** @constructor @param {String} name - name of item @param {THREE.Mesh} model - model to use for the item @param {int} [id] - id of the item @param {object} [functions] - functions that are bound to spesific events @param {function} [functions.onUse] - callback when item is used @param {function} [functions.onSecondary] - callback for second ability @param {function} [functions.onHover] - callback for when cursor is over the item in the inventory (first are is true when mouse goes over, false when mouse leaves) @param {Array} [lore] - flavor text to be displayed when hovering over an object in the inventory @return - new Item */ var Item = function(name, model, id, functions, lore) { lore = lore || []; functions = functions || {}; //there is something there if (lore.length &gt; 0) { var maxLength = 0; this.loreCanvas = document.createElement(&quot;canvas&quot;); var ctx = this.loreCanvas.getContext(&quot;2d&quot;); ctx.font = &quot;100px Arial&quot;; for (var i = 0; i &lt; lore.length; i++) { if (ctx.measureText(lore[i]).width &gt; maxLength) maxLength = ctx.measureText(lore[i]).width; } this.loreCanvas.height = lore.length * 105; this.loreCanvas.width = maxLength; ctx.fillStyle = &quot;#fefefe&quot;; ctx.fillRect(0, 0, maxLength, lore.length * 105); ctx.fillStyle = &quot;black&quot;; ctx.font = &quot;100px Arial&quot;; for (var i = 0; i &lt; lore.length; i++) { ctx.fillText(lore[i], 0, (i + 1) * 100); ctx.stroke(); } var texture = new THREE.Texture(this.loreCanvas); texture.needsUpdate = true; var loreMaterial = new THREE.SpriteMaterial({ map: texture }); this.lore = new THREE.Sprite(loreMaterial); this.lore.scale.set(maxLength / 7, lore.length * 15, 1); } this._unclonedModel = model; try { this.model = model.clone(); } catch(e){ console.warn(e); } this.name = name; this.id = id || Math.floor(Math.random * 10000); this.onUse = functions.onUse || function() {}; this.onSecondary = functions.onSecondary || function() {}; this.clone = function() { return new Item(this.name, this.model, this.id, this.onUse, this.onSecondary); } this.use = function() { return functions.onUse(); } this.secondary = function() { return functions.onSecondary(); } this.hover = function() { return functions.onHover(); } Item.allInstances.push(this); return this; } Item.allInstances = []; /** @constructor @param {Item} item - what item the stack contains @param {int} id - uuid of itemstack @param {int} [ammount] - ammount of items in the stack @return {ItemStack} - the new ItemStack */ var ItemStack = function(item, id, ammount) { this._unclonedItem = item; this.id = id; this.item = item; this.name = item.name; this.ammount = ammount || 1; this.model = this.item.model; this.lore = this.item.lore; this.addItem = function(num) { num = num || 1; this.ammount += num; return this; } /** remove a number of items from the item stack @param {int} num - number of items to be removed */ this.removeItem = function(num) { num = num || 1; this.ammount -= num; return this; } this.use = function() { return this.item.use(); } this.secondary = function() { return this.item.secondary(); } this.getAmmount = function() { return this.ammount; } this.clone = function() { return new ItemStack(this._unclonedItem, this.ammount); } ItemStack.allInstances.push(this); return this; } ItemStack.allInstances = []; × Search results Close Documentation generated by JSDoc 3.4.0 on 2016-05-31T11:24:02+00:00 using the DocStrap template. "},"global.html":{"id":"global.html","title":"Global","body":" GUI.js Namespaces GUI Classes GUI.guiSceneGUI.guiScene#InventoryItemItemStack Tutorials GUI.guiScene#InventoryGUI.guiSceneItem Global animateChatinitkeyuser Global Members key object that tracks the keys pressed Source: client.js, line 17 user Object of all users @private Source: client.js, line 43 Methods animate() Function to render the scene(s) Source: client.js, line 493 Chat(socket) Parameters: Name Type Description socket socket.io socket.io connection to use Source: chat.js, line 5 init() Init function Source: client.js, line 342 × Search results Close Documentation generated by JSDoc 3.4.0 on 2016-05-31T11:24:02+00:00 using the DocStrap template. "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" GUI.js Namespaces GUI Classes GUI.guiSceneGUI.guiScene#InventoryItemItemStack Tutorials GUI.guiScene#InventoryGUI.guiSceneItem Global animateChatinitkeyuser Classes Classes guiScene guiScene#Inventory Item ItemStack Namespaces GUI × Search results Close Documentation generated by JSDoc 3.4.0 on 2016-05-31T11:24:02+00:00 using the DocStrap template. "},"namespaces.list.html":{"id":"namespaces.list.html","title":"Namespaces","body":" GUI.js Namespaces GUI Classes GUI.guiSceneGUI.guiScene#InventoryItemItemStack Tutorials GUI.guiScene#InventoryGUI.guiSceneItem Global animateChatinitkeyuser Namespaces Classes guiScene guiScene#Inventory Item ItemStack Namespaces GUI × Search results Close Documentation generated by JSDoc 3.4.0 on 2016-05-31T11:24:02+00:00 using the DocStrap template. "},"tutorials.list.html":{"id":"tutorials.list.html","title":"Tutorials","body":" GUI.js Namespaces GUI Classes GUI.guiSceneGUI.guiScene#InventoryItemItemStack Tutorials GUI.guiScene#InventoryGUI.guiSceneItem Global animateChatinitkeyuser Tutorials Classes guiScene guiScene#Inventory Item ItemStack Namespaces GUI × Search results Close Documentation generated by JSDoc 3.4.0 on 2016-05-31T11:24:02+00:00 using the DocStrap template. "},"index.html":{"id":"index.html","title":"Index","body":" GUI.js Namespaces GUI Classes GUI.guiSceneGUI.guiScene#InventoryItemItemStack Tutorials GUI.guiScene#InventoryGUI.guiSceneItem Global animateChatinitkeyuser 'Cubes'Copyright (c) 2015 Logan Waldman All Rights Reserved. How To Runrequires: npm , node.js &amp; redis.io To begin: npm install to install all required libraries. Then node main.js to start the server. Now, just point your browser to loacalhost:3000 to see your wonderful game. ConfigurationSee the Wiki Note About VersioningSemantic versioning is overrated. instead, the version x.y.z can be read as major.minor.build, where build is the build number from Heroku. this makes it much easier to find the version you want on Heroku × Search results Close Documentation generated by JSDoc 3.4.0 on 2016-05-31T11:24:02+00:00 using the DocStrap template. "},"GUI.html":{"id":"GUI.html","title":"Namespace: GUI","body":" GUI.js Namespaces GUI Classes GUI.guiSceneGUI.guiScene#InventoryItemItemStack Tutorials GUI.guiScene#InventoryGUI.guiSceneItem Global animateChatinitkeyuser Namespace: GUI GUI Source: GUI.js, line 5 Classes guiScene guiScene#Inventory Members &lt;static&gt; CONTROL_SCHEME_DEFAULT default control scheme Source: GUI.js, line 15 &lt;static&gt; origin center of the scene Source: GUI.js, line 11 × Search results Close Documentation generated by JSDoc 3.4.0 on 2016-05-31T11:24:02+00:00 using the DocStrap template. "},"GUI.guiScene.html":{"id":"GUI.guiScene.html","title":"Class: guiScene","body":" GUI.js Namespaces GUI Classes GUI.guiSceneGUI.guiScene#InventoryItemItemStack Tutorials GUI.guiScene#InventoryGUI.guiSceneItem Global animateChatinitkeyuser Class: guiScene GUI. guiScene new guiScene() Source: GUI.js, line 87 × Search results Close Documentation generated by JSDoc 3.4.0 on 2016-05-31T11:24:02+00:00 using the DocStrap template. "},"GUI.guiScene_Inventory.html":{"id":"GUI.guiScene_Inventory.html","title":"Class: guiScene#Inventory","body":" GUI.js Namespaces GUI Classes GUI.guiSceneGUI.guiScene#InventoryItemItemStack Tutorials GUI.guiScene#InventoryGUI.guiSceneItem Global animateChatinitkeyuser Class: guiScene#Inventory GUI. guiScene#Inventory new guiScene#Inventory(rows, columns [, opts]) Parameters: Name Type Argument Description rows int number of rows in the gui columns int number of columns in gui opts object &lt;optional&gt; options Properties Name Type Argument Description backgroundColor color &lt;optional&gt; background UI color lineColor color &lt;optional&gt; color of lines in UI ctrlScheme object &lt;optional&gt; functions to be called when various buttons are clicked Source: GUI.js, line 173 Methods addItemToEmptySlot(itemStack) add item to the next slot Parameters: Name Type Description itemStack ItemStack the ItemStack to be added Source: GUI.js, line 266 addItemToSlot(itemStack, x, y) adds an item to the selected Slot Parameters: Name Type Description itemStack ItemStack Itemstack to add to the inv x int column to place item in (0 is far left) y int row to place item in (0 is top) Source: GUI.js, line 235 Returns: coordinates that the item were added to Type Array getEmptySlot() find the next empty slot in the inventory Source: GUI.js, line 253 Returns: next empty slot Type Array hide() hides the inventory Source: GUI.js, line 297 locateItem(itemName) find first occurence of item in inventory Parameters: Name Type Description itemName string name of item to find Source: GUI.js, line 338 Returns: coordinates of first occurance of the item Type Array removeItem(x, y) removes item from slot Parameters: Name Type Description x int x-coord of slot to be removed from y int y-coord of slot to be removed from Source: GUI.js, line 276 Returns: removed ItemStack Type ItemStack show() shows the Inventory Source: GUI.js, line 290 toggle() toggles the inventory visiblity Source: GUI.js, line 305 Returns: this update() update function to be called every frame Source: GUI.js, line 316 × Search results Close Documentation generated by JSDoc 3.4.0 on 2016-05-31T11:24:02+00:00 using the DocStrap template. "},"Item.html":{"id":"Item.html","title":"Class: Item","body":" GUI.js Namespaces GUI Classes GUI.guiSceneGUI.guiScene#InventoryItemItemStack Tutorials GUI.guiScene#InventoryGUI.guiSceneItem Global animateChatinitkeyuser Class: Item Item new Item(name, model [, id] [, functions] [, lore]) Parameters: Name Type Argument Description name String name of item model THREE.Mesh model to use for the item id int &lt;optional&gt; id of the item functions object &lt;optional&gt; functions that are bound to spesific events Properties Name Type Argument Description onUse function &lt;optional&gt; callback when item is used onSecondary function &lt;optional&gt; callback for second ability onHover function &lt;optional&gt; callback for when cursor is over the item in the inventory (first are is true when mouse goes over, false when mouse leaves) lore Array &lt;optional&gt; flavor text to be displayed when hovering over an object in the inventory Source: GUI.js, line 414 Returns: - new Item × Search results Close Documentation generated by JSDoc 3.4.0 on 2016-05-31T11:24:02+00:00 using the DocStrap template. "},"ItemStack.html":{"id":"ItemStack.html","title":"Class: ItemStack","body":" GUI.js Namespaces GUI Classes GUI.guiSceneGUI.guiScene#InventoryItemItemStack Tutorials GUI.guiScene#InventoryGUI.guiSceneItem Global animateChatinitkeyuser Class: ItemStack ItemStack new ItemStack(item, id [, ammount]) Parameters: Name Type Argument Description item Item what item the stack contains id int uuid of itemstack ammount int &lt;optional&gt; ammount of items in the stack Source: GUI.js, line 479 Returns: - the new ItemStack Type ItemStack Methods removeItem(num) remove a number of items from the item stack Parameters: Name Type Description num int number of items to be removed Source: GUI.js, line 496 × Search results Close Documentation generated by JSDoc 3.4.0 on 2016-05-31T11:24:02+00:00 using the DocStrap template. "},"tutorial-GUI.guiScene_Inventory_.html":{"id":"tutorial-GUI.guiScene_Inventory_.html","title":"Tutorial: GUI.guiScene#Inventory","body":" GUI.js Namespaces GUI Classes GUI.guiSceneGUI.guiScene#InventoryItemItemStack Tutorials GUI.guiScene#InventoryGUI.guiSceneItem Global animateChatinitkeyuser Inventory Basics GUI.guiScene#Inventory var gui, inventory, renderer; ... function init() { gui = new GUI.guiScene(); inventory = new gui.Inventory(5,9); renderer = new THREE.WebGLRenderer({ alpha: true }); } function update(){ requestAnimationFrame(update); gui.render(renderer); inventory.update(); } ... init(); animate();What it doesthe init function is a common staple of any THREE.js program, and is generaly used as the area to 'set up' anything that will be used for rendering. In this example, we create a new gui scene (new GUI.guiScene();), then a new inventory based on it (new gui.Inventory(5,9);) that is 5 slots tall, by 9 wide. If this code was pasted into a new file, noting would be seen. This is because the inventory is hidden by default[Citation Needed], so we must place a call to inventory.show(); at the end of the init function to show the gui. × Search results Close Documentation generated by JSDoc 3.4.0 on 2016-05-31T11:24:02+00:00 using the DocStrap template. "},"tutorial-InventoryBasics.html":{"id":"tutorial-InventoryBasics.html","title":"Tutorial: Inventory Basics","body":" GUI.js Namespaces GUI Classes GUI.guiSceneGUI.guiScene#InventoryItemItemStack Tutorials GUI.guiScene#InventoryGUI.guiSceneItem Global animateChatinitkeyuser Inventory Basics To get started, we must already have the basics of a game in place. ... var itemOne = new Item(&quot;itemOne&quot;); var itemTwo = new Item(&quot;itemTwo&quot;); ... × Search results Close Documentation generated by JSDoc 3.4.0 on 2016-05-31T11:24:02+00:00 using the DocStrap template. "},"tutorial-GUI.guiScene_.html":{"id":"tutorial-GUI.guiScene_.html","title":"Tutorial: GUI.guiScene","body":" GUI.js Namespaces GUI Classes GUI.guiSceneGUI.guiScene#InventoryItemItemStack Tutorials GUI.guiScene#InventoryGUI.guiSceneItem Global animateChatinitkeyuser GUI.guiScene GUI.guiScene()this is the primary construtor for GUI. Sample code: ... function init() { var gui = new GUI.guiScene(); } function update() { gui.render(); } ... × Search results Close Documentation generated by JSDoc 3.4.0 on 2016-05-31T11:24:02+00:00 using the DocStrap template. "},"tutorial-Item_.html":{"id":"tutorial-Item_.html","title":"Tutorial: Item","body":" GUI.js Namespaces GUI Classes GUI.guiSceneGUI.guiScene#InventoryItemItemStack Tutorials GUI.guiScene#InventoryGUI.guiSceneItem Global animateChatinitkeyuser Item var objLoader = new THREE.ObjLoader(); var itemOneModel; jsonLoader.load('./demo.obj',function(data) { itemOneModel = data; }); var itemOne = new Item(&quot;itemOne&quot;,itemOneModel); var demoItemStack = new ItemStack(itemOne,1);What it doesthe first 5 lines of code simply create the 3D model for use later, and are not a part of this tutorial. After that, we simply create an item named itemOne with our model, then create an itemstack with one item in it × Search results Close Documentation generated by JSDoc 3.4.0 on 2016-05-31T11:24:02+00:00 using the DocStrap template. "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
